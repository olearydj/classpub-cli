from __future__ import annotations

import datetime as _dt
import os
import shutil
from pathlib import Path
from typing import Callable

from . import __version__
from .paths import PENDING, MANIFEST
from .utils import _atomic_write

# Justfile template
_JUSTFILE_TEMPLATE = """# Justfile for Classpub — generated by classpub {version}
# Re-generate with: classpub setup

[private]
default:
    @just --list

# --- CLI Proxies (prefer these commands) ---

# Show CLI help
help:
    @{runner} --help

# Show CLI version
version:
    @{runner} --version

# Initialize manifest (idempotent)
init:
    @{runner} init

# Validate repository
validate:
    @{runner} validate

# Mark a file/folder under pending/ for release
release item:
    @{runner} release "{{item}}"

[private]
# Alias for release (git-style naming)
add item:
    @just release "{{item}}"

# Remove a file/folder from release manifest
remove item:
    @{runner} remove "{{item}}"

# Implemented commands
check:
    @{runner} check

# Synchronize files to preview folder
sync args="":
    @{runner} sync {{args}}

# Diff tracked content or specific item
diff item="":
    @{runner} diff {{item}}

# Convert notebooks to Markdown
to-md args="":
    @{runner} to-md {{args}}

# Remove file cruft, e.g., .ipynb_checkpoints
clean:
     @{runner} clean

# Pass-through runner for advanced usage
run *args:
    @{runner} {{args}}
"""


_GITIGNORE_LINES = (
    "# added by classpub",
    "",
    "preview/",
    "pending/md/",
    ".DS_Store",
    ".ipynb_checkpoints/",
)


_CLASSPUB_TOML = """# classpub.toml
# all options provided as comments with default settings

[general]
# strict = false      # Treat warnings as errors (validate exits 1).
# assume_yes = false  # Auto-confirm destructive prompts (e.g., sync removals).

[sync]
# dry_run = false            # Compute the plan without writing.
# large_file_warn_mb = 100   # Warn when hashing files larger than this size (MB).

[ignore]
# patterns = [
#   ".DS_Store",
#   ".gitignore",
#   ".gitattributes",
#   ".ipynb_checkpoints/",
#   "RELEASES.txt",
# ]

[hash]
# chunk_size = 8192   # Streaming chunk size in bytes for hashing.

[logging]
# level = "INFO"      # One of: ERROR, WARNING, INFO, DEBUG
# format = "human"    # One of: human, json
# timestamps = true    # Include timestamps in logs (JSON always includes ISO8601)
"""


_WORKFLOW_YML = r"""name: Publish Public Content

on:
  push:
    branches: [ main ]
    paths:
      - 'pending/**'
  workflow_dispatch:

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout private repo
      uses: actions/checkout@v4
      with:
        path: private

    - name: Checkout public repo
      uses: actions/checkout@v4
      with:
        repository: OWNER/REPO
        token: ${{ secrets.PUBLIC_REPO_TOKEN }}
        path: public-repo

    - name: Install just command runner
      run: |
        curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin

    - name: Install nbstripout
      run: |
        pip install nbstripout

    - name: Generate preview content
      run: |
        cd private
        just sync

    - name: Clear old content
      run: |
        cd public-repo
        git rm -rf .
        git clean -fdx

    - name: Copy generated preview content
      run: |
        rsync -avL --exclude='.ipynb_checkpoints' \
                   --exclude='.DS_Store' \
                   --exclude='.*' \
                   private/preview/ public-repo/

    - name: Strip notebook outputs
      run: |
        find public-repo -name "*.ipynb" -type f -exec nbstripout {} \; \
          -o -name "__never__" -print >/dev/null
        echo "✓ Cleared outputs from all notebooks"

    - name: Commit and push
      run: |
        cd public-repo
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        git add -A
        if git diff --staged --quiet; then
          echo "No changes to publish"
        else
          git commit -m "Update public content from private repo"
          git push
        fi
"""


def _timestamp() -> str:
    return _dt.datetime.now(_dt.timezone.utc).strftime("%Y%m%d%H%M%S")


def _backup(path: Path) -> Path:
    backup = path.with_name(f"{path.name}.bak-{_timestamp()}")
    shutil.move(str(path), str(backup))
    return backup


def _ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


def _merge_gitignore(path: Path) -> tuple[int, bool]:
    created = False
    existing_lines: list[str] = []
    existing_set: set[str] = set()
    if path.exists():
        try:
            existing_lines = [ln.rstrip("\n") for ln in path.read_text(encoding="utf-8").splitlines()]
            existing_set = set(existing_lines)
        except Exception:
            existing_lines = []
            existing_set = set()
    else:
        created = True
    to_add = [ln for ln in _GITIGNORE_LINES if ln not in existing_set]
    if not to_add:
        return 0, created
    content = "\n".join(existing_lines)
    if content and not content.endswith("\n"):
        content += "\n"
    content += "\n".join(to_add) + "\n"
    _atomic_write(path, content)
    return len(to_add), created


def _justfile_content_uv_only() -> str:
    safe = _JUSTFILE_TEMPLATE.replace("{{", "[[").replace("}}", "]]")
    rendered = safe.format(version=__version__, runner="uv run classpub")
    return rendered.replace("[[", "{{").replace("]]", "}}")


def _is_self_repo(root: Path) -> bool:
    try:
        if (root / "src" / "classpub_cli").exists():
            return True
        py = root / "pyproject.toml"
        if py.exists():
            body = py.read_text(encoding="utf-8")
            if "name = \"classpub-cli\"" in body:
                return True
    except Exception:
        return False
    return False


def run_install(*, dry_run: bool, skip_ci: bool, force: bool = False, console_print: Callable[[str], None]) -> int:
    """Install project scaffolding for classpub.

    Always writes a new justfile (backing up an existing one), merges .gitignore,
    creates pending/ and pending/md/, ensures manifest exists, writes classpub.toml
    if missing, and writes a CI workflow unless --skip-ci is used.
    """
    root = Path.cwd()

    # Safety: avoid running in the classpub-cli repository unless forced
    if _is_self_repo(root) and not force:
        console_print("❌ Refusing to run setup in the classpub-cli repository. Use --force to override.")
        return 1

    # Ensure minimal directories (pending/ only)
    created_dirs: list[str] = []
    if not PENDING.exists():
        created_dirs.append(PENDING.as_posix())
        if not dry_run:
            _ensure_dir(PENDING)

    # Manifest header if missing
    manifest_created = False
    if not MANIFEST.exists():
        manifest_created = True
        if not dry_run:
            header = (
                "# Released Files (manifest)\n"
                "# Add files (e.g., notebooks/01.ipynb) or folders with trailing / (e.g., data/)\n"
                "# Lines starting with # are comments. Empty lines are ignored.\n"
            )
            MANIFEST.parent.mkdir(parents=True, exist_ok=True)
            MANIFEST.write_text(header, encoding="utf-8")

    # Write justfile with backup
    just_path = root / "justfile"
    backed_up_to: Path | None = None
    if just_path.exists():
        backed_up_to = just_path.with_name(f"justfile.bak-{_timestamp()}")
        if not dry_run:
            shutil.copy2(just_path, backed_up_to)
    just_text = _justfile_content_uv_only()
    if not dry_run:
        _atomic_write(just_path, just_text)

    # Merge .gitignore
    added_ignores, created_ign = _merge_gitignore(root / ".gitignore")

    # Write classpub.toml if missing
    toml_path = root / "classpub.toml"
    toml_created = False
    if not toml_path.exists():
        toml_created = True
        if not dry_run:
            _atomic_write(toml_path, _CLASSPUB_TOML)

    # Workflow (optional)
    wf_path = root / ".github" / "workflows" / "publish-public.yml"
    wf_created = False
    if not skip_ci:
        if not wf_path.exists():
            wf_created = True
            if not dry_run:
                _ensure_dir(wf_path.parent)
                _atomic_write(wf_path, _WORKFLOW_YML)

    # Report
    for d in created_dirs:
        console_print(f"✓ Created {d}/")
    if manifest_created:
        console_print("✓ Created pending/RELEASES.txt")
    if backed_up_to is not None:
        console_print(f"✓ Backed up existing justfile to {backed_up_to.name}")
    console_print("✓ Wrote justfile (proxy to classpub)")
    if created_ign and added_ignores:
        console_print(f"✓ Updated .gitignore (+{added_ignores} entries)")
    elif created_ign:
        console_print("✓ Updated .gitignore")
    elif added_ignores:
        console_print(f"✓ Updated .gitignore (+{added_ignores} entries)")
    if toml_created:
        console_print("✓ Created classpub.toml")
    if wf_created:
        console_print("✓ Created .github/workflows/publish-public.yml (edit repository: OWNER/REPO)")
    console_print("✓ Setup complete")
    # Next steps guidance
    console_print("\nTo configure git / GitHub:")
    console_print("  1) Edit .github/workflows/publish-public.yml → set repository: OWNER/REPO")
    console_print("  2) Create the public GitHub repo and add PRIVATE repo secret: PUBLIC_REPO_TOKEN")
    console_print("  3) Initialize git if needed: git init && git branch -M main && git remote add origin <PRIVATE>")
    console_print("  4) Run: just validate && just check && just sync --dry-run")
    console_print("\nUsage:")
    console_print("  `uv run classpub --help`")
    console_print("  or use 'just' interface: `just --list` - install with `brew install just`")

    return 0


